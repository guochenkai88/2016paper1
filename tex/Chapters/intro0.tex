\section{Introduction}
Android platform has been already proven to be prevalent as a typical operating system installed in nowadays smartphone and tablet. The sound performance and effective work on those user-hospital devices have proven Android system has a great advantage in user interaction and GUI expressing. One of the key points of Android raising such successes falls on the decent utility of event-driven and callback mechanism that are quite different from traditional software on design level. Due to amounts interactions with user, the program developed on Android system has to design its program logic in a pending way.  That is to say, the program control flow changes corresponding to certain events without a pre-defined logic(e.g., a launching main function). Such even-driven design can guarantee the logic flexibility in front of different scenes in practise. Normally, an effective event can trigger a certain callback method executing. The callback methods provide an asynchronous way for a specific class to invoke certain method when a certain event happens. For example, a typical onClick callback method defined in the button OnClickListener interface is always invoked after the certain registered button is clicked by user. Developer can arrange corresponding repose logics in the onClick callback, like jumping to another activity or popping up a notice dialog. However, these logics are not executed until the click event happens.

There are a variety of events that can trigger certain callback APIs provided by Android. Generally, each event is related to the callbacks belonging to a single specific app. For instance, the explicit intent specifies the single address(package name) of the targeted recipient and sends the intent out through a broadcast event. When the event is received by the specified single app, only the callback (e.g., onReceive method in broadcast receiver) in the recipient would be executed. Under the protection of sandbox, other app is hard to obtain the intent content from the event or the targeted recipient on the application level. And even the entire broadcast process is properly protected by such single receiver mechanism. 

However, not all the cases emerge so ideally. There still exists a large spectrum of public events that can trigger the execution of callbacks from different components and even different apps. We call this kind of trigger events PE(public events) and corresponding callbacks PECs(public event callbacks). Examples of PE include system event, implicit intent, service running status, etc. The PE offers the same trigger source to callback executions from different apps. Such characteristic contains potential threats that an evil app can sniff the execution time of specific callback within a victim app, so long as an understanding about the victim's program logic has been prepared. We consider the PEC as a severe threats for it offers an accurate way to predict the execution timing, which is widely exploited by existing UI attacks\cite{chen2014peeking}\cite{bianchi2015app}\cite{ren2015towards}. A typical PEC case is about the "Shake" module of the popular app Wechat. In the "Shake" scene, a random online friend is recommended after the user slightly shake(acts as the PE) the device. However, an adversary app running on the background can also capture the shake action, so that it can judge the timing of certain foreground display in the Wechat. Further, the adversary app is able to craft attacks like phishing and spoofing exploiting the judgement to the foreground. The PEC is insensitive on surface but offers attack materials for other apps with evil purpose. To the end, such threats can evolve into various types of attacks that we will present in a great detail in section 4.

%Besides, the events from system, other apps or life-cycle have similar callback responding mechanism. 
%Such event-driven and callback mechanism make a huge challenge on analysis of certain applications installed in Android. 

To the best of our knowledge, there has not a previous work exclusively focusing on analysing and tackling the issues arising by the PEC threats. In this paper, we first engage a comprehensive analysis and a large scale of market apps survey about the PEC. Fortunately, Android ecosystem provider a relatively open environment allowing one to make a pre-analysis of a targeted app off-line. Such feature makes it possible to identify the potential victim apps suffering from the PEC threats. Nonetheless, the identification to the PEC within a certain app should overcome two main challenges. One is that attackers have to obtain materials of targeted apps on the code level overcoming the code confusion. The other one is to detect out at least one feasible inferring path across numerous control flow paths within the targeted app. Such path should contain a callback function that can be invoked by an exposed public event and a display-sink(e.g., startActivity or Toast.makeText) point with exposure features. For all, it is entirely possible to identify a victim for a wily attacker. 

%The other challenge is that it should be detected that existing a determinable path from the start of such callback function to the display-sink, which involves fine-grain control flow analysis. To achieve this goal, branch conditions and method invocation have to be properly handled to avoid the restriction of permission request and user-interaction.

Based on above consideration, it has a substantial value to conduct a previous evaluation for current common-used market apps. We implement a prototype static analyzer CSDroid with 4k lines python codes to automatically conduct the PEC identification to 2375** apps collected from Googly Play. Of all the targeted apps, we find 783** such sensitive paths within 354** targeted apps, including some popular apps like **. Moreover, it's surprising that 69\% **  of apps with service component suffer from such threats, which alerts us a high risk of such potential security threats within background components widely existing in generic apps.  

%Given such an app with certain PEC weaknesses, an adversary attacker could devise a rich variety of attacks. Since such attacks are mainly based on the display-sink, the attack types are somehow similar with traditional UI attacks. However, as the display-sink should be reasonably inferred from the PEC, adversary app needs to concern more details about time-delay and program flow conditions. Besides that, traditional UI attacks mainly rely on activity display of victim app; display-sink contains more types of displays such as dialog and notification, which allow attackers to flexibly craft more attacks contents. To validate the feasibility of such PEC weaknesses exploitation, we explore and implement a set of proof-of-concept attacks based on such threats, including not only traditional phishing and spoofing to sensitive pages, but also newly dialog and notification exploitation for privilege escalation and other privacy steal. 

To migrate the impact of such PEC threats, we also discuss corresponding defence strategy. 

To summarize, the main contribution of this paper are:

1. We systematically study vulnerabilities of Android app lead by abuse of public event callbacks as well as discover various {\color{red}four} types of attack vectors leading to such PEC threats. 
 
2. By a set of corresponding proof-of-concept attacks, we validate the feasibility of such PEC exploitation and illustrate the severity of such threats. 

3. We introduce a tool implemented to automatically detect the PEC threats within targeted apps. By our study, a wide range of apps are affected by PEC attacks.

4. We provide a mitigation strategy to the PEC threats, under which a more security callback invoking mechanism can be established.

%On the other side, Android sandbox is known as an effect mechanism to protect apps from other one's attack. Sandbox restricts the resources to be offered for certain independent entities, leaving only very few ways for them to communicate with others. Actually, through the usage of conventional so-called side-channels, certain indirect inferring gradually evolves into a typical sort of attacks. In general, this sort of attacks threat a broad range of apps causing side-channels(such as process status) exist in system level. In other words, most of developed apps would be unable to avoid the influence brought by features from system level. Nevertheless, the impact appears limited for the deviation posed by sophisticated algorithms from current side-channel approaches. For instance, \cite{chen2014peeking}(UI state) treats several selected process statuses as side-channels, and utilizes them to infer a proper emergence time for the fake phishing Activity devised by attackers. However, the critical inference bases on a series of data collection and computations, leading to an inevitable derivation in term of device and targeted app itself. A typical example is that the typical Activity transition signal presence in \cite{chen2014peeking} is quite week and the shape is also changed in our reproducing experiment. Thus, using the same procedures as proposed in \cite{chen2014peeking} would hardly perform an ideal attack. The similar situation exists in other existing side-channel attacks aiming to Android apps as well \cite{zhou2013identity}\cite{jana2012memento}.
